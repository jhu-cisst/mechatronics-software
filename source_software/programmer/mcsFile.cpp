/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-    */
/* ex: set filetype=cpp softtabstop=4 shiftwidth=4 tabstop=4 cindent expandtab: */

#include <iostream>
#include <iomanip>
#include <string.h>

#include "mcsFile.h"

mcsFile::mcsFile() : line_num(0), startAddr(0L)
{
}

mcsFile::~mcsFile()
{
}

bool mcsFile::ProcessNextLine(RecInfo &rec)
{
    // MCS file generated by ISE has line lengths no larger than 43 bytes
    const int MCS_LINE_MAX = 64;
    char buffer[MCS_LINE_MAX];

    file.getline(buffer, sizeof(buffer));
    line_num++;
    if (file.eof()) return false;

    if (buffer[0] != ':') return false;
    int nbytes = static_cast<int>(file.gcount());
    if (nbytes >= MCS_LINE_MAX) {
        // If this error occurs, increase MCS_LINE_MAX
        std::cerr << "ProcessNextLine: line " << line_num
                  << " has too many characters, nbytes = " << nbytes << std::endl;
        return false;
    }
    if (!buffer[nbytes-1]) nbytes--;

    unsigned long csum_computed = 0L;
    if (!toHex(buffer+1, rec.ndata)) return false;
    csum_computed += rec.ndata;
    if (rec.ndata > sizeof(rec.data)) {
        // If this error occurs, increase RecInfo::DATA_MAX
        std::cerr << "ProcessNextLine: line " << line_num
                  << " has too much data, num bytes = " << rec.ndata << std::endl;
        return false;
    }
    unsigned char addr_high, addr_low;
    if (!toHex(buffer+3, addr_high)) return false;
    csum_computed += addr_high;
    if (!toHex(buffer+5, addr_low)) return false;
    csum_computed += addr_low;
    rec.addr = (addr_high<<8)+addr_low;
    if (!toHex(buffer+7, rec.type)) return false;
    csum_computed += rec.type;

    // convert to binary and compute checksum
    for (unsigned int i = 0; i < rec.ndata; i++) {
        if (!toHex(buffer+9+2*i, rec.data[i])) return false;
        csum_computed += rec.data[i];
    }
    unsigned char cksum;
    if (!toHex(buffer+9+2*rec.ndata, cksum)) return false;
    csum_computed += cksum;
    
    csum_computed &= 0x000000ff;
    if (csum_computed) {
        std::cerr << "ProcessNextLine: line " << line_num
                  << " checksum error = " << csum_computed << std::endl;
        return false;
    }
    return true;
}

bool mcsFile::toHex(const char *p2, unsigned char &result) const
{
    const unsigned int NUM_DIGITS = 2;
    unsigned char digit[NUM_DIGITS];
    result = 0;
    for (unsigned int i = 0; i < NUM_DIGITS; i++) {
        digit[i] = p2[i]-'0';
        if (digit[i] > 9) {
            digit[i] = toupper(p2[i])-'A';
            if (digit[i] > 5) return false;
            digit[i] += 10;
        }
        result |= digit[i] << (4*(NUM_DIGITS-i-1));
    }
    return true;
}

bool mcsFile::OpenFile(const std::string &fileName)
{
    file.open(fileName.c_str());
    if (!file.is_open()) {
        std::cerr << "mcsFile: could not open input file " << fileName << std::endl;
        return false;
    }
    line_num = 0;
    return true;
}

bool mcsFile::ReadNextSector()
{
    RecInfo rec;
    if (!ProcessNextLine(rec)) return false;
    if (rec.type != RECORD_EXT_LINEAR) {
        std::cerr << "ReadNextSector: line " << line_num << " does not start a sector" << std::endl;
        return false;
    }
    if (rec.ndata != 2) {
        std::cerr << "ReadNextSector: line " << line_num << " has invalid data length = "
                  << rec.ndata << std::endl;
        return false;
    }
    startAddr = ((rec.data[0]<<16)+rec.data[1]) << 16;
    numBytes = 0L;
    while ((numBytes < sizeof(curSector)) && ProcessNextLine(rec)) {
        if (rec.type == RECORD_DATA) {
            if (numBytes != rec.addr) {
                std::cerr << "ReadNextSector: line " << line_num
                          << ", expected offset " << numBytes << ", got offset "
                          << rec.addr << std::endl;
                return false;
            }
            memcpy(curSector+numBytes, rec.data, rec.ndata);
            numBytes += rec.ndata;
        }
        else if (rec.type == RECORD_EOF)
            break;
        else
            std::cerr << "ReadNextSector: line " << line_num 
                      << " ignoring record type " << rec.type << std::endl;
    }
    // Pad sector with 0xff, just in case
    if (numBytes < sizeof(curSector)) {
        memset(curSector+numBytes, 0xff, sizeof(curSector)-numBytes);
    }
    else if (numBytes > sizeof(curSector))
        std::cerr << "ReadNextSector: too many bytes = " << numBytes << std::endl;
    return true;
}

bool mcsFile::VerifySector(const unsigned char *data, unsigned long len) const
{
    unsigned int lim = (len < sizeof(curSector)) ? len : sizeof(curSector);
    int num = 0;  // number of mismatches
    unsigned int i;
    for (i = 0; i < lim; i++) {
        if (curSector[i] != data[i]) {
            std::cout << std::hex << "Mismatch at address " << startAddr+i
                      << ", file = " << (unsigned int)curSector[i]
                      << ", prom = " << (unsigned int)data[i] << std::endl;
            if (++num >= 10)
                break;
        }
    }
    return (i == lim) && (num == 0);
}

void mcsFile::Rewind()
{
    file.clear();
    file.seekg(0, std::ios_base::beg);
}

void mcsFile::CloseFile()
{
    std::cout << "Processed " << line_num << " lines" << std::endl;
    file.close();
}

void mcsFile::WriteSectorHeader(std::ofstream &file, unsigned int num)
{
    file << std::hex << std::setfill('0') << std::uppercase;
    file << ":" << std::hex << "02000004";
    unsigned long csum_computed = 0x02 + 0x04;
    file << std::setw(4) << static_cast<unsigned short>(num);
    csum_computed += num&0x000000ff;
    csum_computed += (num&0x0000ff00)>>8;
    csum_computed = (~csum_computed+1)&0x000000ff;
    file << std::setw(2) << csum_computed << std::endl;
}

void mcsFile::WriteDataLine(std::ofstream &file, unsigned long addr, unsigned char *bytes, unsigned int numBytes)
{
    if (numBytes == 0) return;
    file << ":" << std::setw(2) << numBytes;
    unsigned long csum_computed = numBytes;
    file << std::setw(4) << static_cast<unsigned short>(addr);
    csum_computed += addr&0x000000ff;
    csum_computed += (addr&0x0000ff00)>>8;
    file << "00";   // type = RECORD_DATA
    for (unsigned int i = 0; i < numBytes; i++) {
        csum_computed += bytes[i];
        file << std::setw(2) << (unsigned int) bytes[i];
    }
    csum_computed = (~csum_computed+1)&0x000000ff;
    file << std::setw(2) << csum_computed << std::endl;
}

void mcsFile::WriteEOF(std::ofstream &file)
{
    file << ":00000001FF" << std::endl;
}
